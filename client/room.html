<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Build a Thing Video App</title>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <div id="app">
      <main id="videos">
        <nav>
          <form id="lock-room" @submit.prevent="lockRoom">
            <input type="text" id="access-code" placeholder="Access Code" :disabled="roomLocked" v-model="inputAccessCode" />
            <button id="lock-button" :class="{ 'lock-button': true, 'locked': roomLocked, 'unlocked': !roomLocked }">{{ roomLocked ? "Click to Unlock" : "Click to Lock" }}</button>
          </form>
        </nav>
        <section class="video-streams video-streams__publishers">
          <h2>Publishers</h2>
          <div id="publishers"></div>
        </section>
        <section class="video-streams video-streams__subscribers">
          <h2>Subscribers</h2>
          <div id="subscribers"></div>
        </section>
        <section class="background-preferences">
          <button @click="background.open = !background.open">{{ background.open ? 'Close' : 'Customize Background' }}</button>
          <div class="content" ref="backgroundContent">
            <video  class="hidden"  ref="inputVideo"      :width="output.width" :height="output.height" autoplay @play="handleInputPlay" ></video>
            <canvas class="preview" ref="outputCanvas"    :width="output.width" :height="output.height"></canvas>
            <canvas class="hidden"  ref="workspaceCanvas" :width="output.width" :height="output.height"></canvas>
            <button @click="output.playing = !output.playing">{{ output.playing ? 'Pause' : 'Play' }}</button>
            <form autocomplete="off" ref="backgroundForm">
              <fieldset>
                <legend>Background</legend>
                <span>

                  <label for="image-input">Image</label>
                  <span>
                    <input id="image-input" type="file" ref="imageInput" @change="handleBackgroundImageChange" />
                    <button id="remove-image" type="button" @click="removeBackgroundImage">Clear</button>
                  </span>

                  <label for="preview-overlay-input">Preview Overlay</label>
                  <input id="preview-overlay-input" type="checkbox" :disabled="!background.image" v-model="background.values.previewOverlay" />

                  <label for="x-input">X</label>
                  <input id="x-input" type="number" step="1" :disabled="!background.image" v-model.number="background.values.x" />

                  <label for="y-input">Y</label>
                  <input id="y-input" type="number" step="1" :disabled="!background.image" v-model.number="background.values.y" />

                  <label for="width-input">Width</label>
                  <input id="width-input" type="number" min="0" step="1" :disabled="!background.image" v-model.number="background.values.width" />

                  <label for="height-input">Height</label>
                  <input id="height-input" type="number" min="0" step="1" :disabled="!background.image" v-model.number="background.values.height" />

                  <label for="darkestChroma-input">Chroma Dark</label>
                  <input id="darkestChroma-input" type="color" :disabled="!background.image" v-model="background.values.darkestChroma" />

                  <label for="lightestChroma-input">Chroma Light</label>
                  <input id="lightestChroma-input" type="color" :disabled="!background.image" v-model="background.values.lightestChroma" />

                  <label for="tolerance-input">Tolerance</label>
                  <input id="tolerance-input" type="number" min="0.0001" max="1" step="0.001" :disabled="!background.image" v-model.number="background.values.tolerance" />
                </span>
              </fieldset>
              <fieldset>
                <legend>Output</legend>
                <span>
                  <label for="output-width-input">Width</label>
                  <input id="output-width-input" type="number" min="0" step="1" v-model.number="output.width" />

                  <label for="output-height-input">Height</label>
                  <input id="output-height-input" type="number" min="0" step="1" v-model.number="output.height" />

                  <label for="output-fps-input">FPS</label>
                  <input id="output-fps-input" type="number" min="0" step="1" v-model.number="output.frameRate" />
                </span>
              </fieldset>
            </form>
          </did>
        </section>
      </main>
      <aside id="chat">
        <ul id="messages">
          <li v-for="item in messages">
            <label>{{item.username}}</label>
            <div>{{item.message}}</div>
          </li>
        </ul>
        <form id="new-message" @submit.prevent="submitMessage">
          <input type="text" id="message" placeholder="New Message..." v-model="newMessage" />
          <button>Send</button>
        </form>
      </aside>
    </div>

    <script src="https://static.opentok.com/v2/js/opentok.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
    <script>
      /**
       * Create Promise that delays by ms
       */
      const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

      const app = new Vue({
        el: '#app',
        data: {
          session: undefined,
          camera: undefined,
          subscribers: [],
          roomLocked: false,
          resp: undefined,
          inputAccessCode: '',
          messages: [],
          newMessage: '',
          background: {
            values: {
              previewOverlay: false,
              x: 0,
              y: 0,
              width: 0,
              height: 0,
              darkestChroma: '#63992E',
              lightestChroma: '#00FF55',
              tolerance: 0.05,
            },
            image: undefined,
            open: false,
            context: undefined,
            worker: undefined
          },
          output: {
            width: 0,
            height: 0,
            frameRate: 60,
            playing: false,
            context: undefined
          },
          lastRender: 0
        },
        mounted(){
          this.output.context = this.$refs.outputCanvas.getContext('2d');
          this.background.context = this.$refs.workspaceCanvas.getContext('2d');
        },
        async created() {
          this.spawnWorker();
          Object.entries(this.background.values).forEach(([key, value]) =>
            this.$watch(`background.values.${key}`, (...args) => this.updateBackgroundSetting(key, ...args))
          );
          this.resp = await fetch(`/api/session?room=${this.params.id}&code=${this.params.code}`).then(r => r.json())
          const { apiKey, sessionId, token, locked, access } = this.resp
          if(!access) window.location.replace(`/access-required?id=${this.params.id}&username=${this.params.username}`)
          this.session = OT.initSession(apiKey, sessionId)
          const userStream = await this.getUserStream();
          this.camera = OT.initPublisher('publishers', { mirror: false, name: this.params.username, insertMode: 'append', videoSource: userStream.getVideoTracks()[0], audioSource: userStream.getAudioTracks()[0] })
          this.roomLocked = locked
          this.setLock(this.roomLocked,(this.params.code ? this.params.code : ""))
          this.session.connect(token, () => { this.session.publish(this.camera) })
          this.session.on('streamCreated', event => {
            this.subscribers.push(event.stream)
            this.session.subscribe(event.stream, 'subscribers', { insertMode: 'append' })
          })
          this.session.on('streamDestroyed', event => {
            this.subscribers = this.subscribers.filter(sub => sub.id != event.stream.id)
          })
          this.session.on('signal', event => {
            switch (event.type) {
              case 'signal:message':
                this.messages.push(JSON.parse(event.data))
                break
              case 'signal:lock':
                const lockData = JSON.parse(event.data)
                this.setLock(lockData.lock,lockData.code)
                break
            }
          })
        },
        methods: {
          setLock(locked, code) {
            this.inputAccessCode = code
            this.roomLocked = locked
          },
          submitMessage() {
            if(this.newMessage) {
              this.session.signal({
                data: JSON.stringify({username: this.params.username, message: this.newMessage }),
                type: 'message'
              })
              this.newMessage = ''
            }
          },
          async lockRoom() {
            const { apiKey, sessionId, token, locked } = await fetch(`/api/session?room=${this.params.id}&lock=${!this.roomLocked}&code=${this.inputAccessCode}`).then(r => r.json())
            this.roomLocked = locked
            this.session.signal({
              data: JSON.stringify({lock: locked, code: this.inputAccessCode }),
              type: 'lock'
            })
            this.setLock(this.roomLocked, this.inputAccessCode)
          },
          spawnWorker(){
            this.background.worker = new Worker('./worker.js');
            this.background.worker.addEventListener('message', ({ data: { buffer, width, height }}) => {
              // Only message sent from worker is the updated image data
              const imageData = new ImageData(new Uint8ClampedArray(buffer), width, height);
              this.output.context.putImageData(imageData, 0, 0);
              requestAnimationFrame(this.renderFrame);
            });
          },
          async getUserStream(){
            const inputStream = await navigator.mediaDevices.getUserMedia({ video: true });
            this.$refs.inputVideo.srcObject = inputStream;

            const stream = this.$refs.outputCanvas.captureStream();
            const audioTracks = (this.$refs.inputVideo.audioTracks || []);
            if (audioTracks.length) stream.addTrack(audioTracks[0]);
            return stream;
          },
          removeBackgroundImage(){
            this.background.image = null;
            this.background.worker.postMessage({ action: 'removeBackgroundImage' });
            this.$refs.imageInput.value = '';
          },
          setBackgroundImage(image, limitToInputVideoSize){
            let { width, height } = image;

            if (limitToInputVideoSize){
              // Reduce image size to be less then the input video size while maintaining aspect ratio
              if (width > this.$refs.inputVideo.width){
                const ratio = width / height;
                width = Math.min(width, this.$refs.inputVideo.width);
                height = width / ratio;
              }

              if (height > this.$refs.inputVideo.height){
                const ratio = height / width;
                height = Math.min(height, this.$refs.inputVideo.height);
                width = height / ratio;
              }

              image.width = width;
              image.height = height;
            }

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;

            // Update form values
            this.background.values.width = width;
            this.background.values.height = height;

            // Save image for future resolution adjustments
            this.background.image = image;

            const context = canvas.getContext('2d');
            context.drawImage(image, 0, 0, width, height);

            const imageData = context.getImageData(0, 0, width, height);
            this.background.worker.postMessage({
              action: 'setBackgroundImage',
              data: {
                buffer: imageData.data.buffer,
                width: imageData.width,
                height: imageData.height
              }
            }, [imageData.data.buffer]);
          },
          handleBackgroundImageChange({ target: { files }}){
            if (!files.length) return;

            const imageFile = files[0];

            // Convert file to image
            const image = new Image();
            image.onload = () => this.setBackgroundImage(image, true);
            image.src = URL.createObjectURL(imageFile);
          },
          updateBackgroundSetting(key, value){
            if (value === '') return;

            switch(key){
              case 'x':
              case 'y':
              case 'tolerance':
              case 'previewOverlay':
              case 'darkestChroma':
              case 'lightestChroma':
                return this.background.worker.postMessage({
                  action: 'updateBackgroundSettings',
                  data: { key, value }
                });
              case 'width':
              case 'height':
                // Update the dimensions of the image and update the image data
                this.background.image[key] = value;
                return this.setBackgroundImage(this.background.image, false);
              default:
                console.error(`Unexpected background setting key: ${key}`);
            }
          },
          handleInputPlay(){
            this.output.playing = true;
            this.output.width = this.$refs.inputVideo.videoWidth;
            this.output.height = this.$refs.inputVideo.videoHeight;
            // Get frame rate and start rendering
            this.output.frameRate = this.$refs.inputVideo.srcObject.getVideoTracks()[0].getSettings().frameRate;
            this.renderFrame();
          },
          renderFrame(){
            // Prevent rendering faster then the frame rate of the input video
            const now = performance.now();
            if (now - this.lastRender < 1000 / this.output.frameRate) return requestAnimationFrame(this.renderFrame);
            this.lastRender = now;

            // Stop rendering if the video is stopped
            if (this.$refs.inputVideo.ended) return;

            if (this.background.image) {
              // Pass frame data to worker
              this.background.context.drawImage(this.$refs.inputVideo, 0, 0, this.output.width, this.output.height);
              const imageData = this.background.context.getImageData(0, 0, this.output.width, this.output.height);
              this.background.worker.postMessage({
                action: 'applyGreenscreenEffect',
                data: {
                  buffer: imageData.data.buffer,
                  width: imageData.width,
                  height: imageData.height
                }
              }, [imageData.data.buffer]);
              return;
            }

            // There is no background, pass image directly to the output canvas
            this.output.context.drawImage(this.$refs.inputVideo, 0, 0, this.output.width, this.output.height);
            requestAnimationFrame(this.renderFrame);
          }
        },
        watch: {
          'output.playing'(playing){
            if (playing) this.$refs.inputVideo.play();
            else this.$refs.inputVideo.pause();
          },
          async 'background.open'(open){
            const content = this.$refs.backgroundContent;

            if (!open) {
              content.style.maxHeight = null;
              await delay(1800);
              content.classList.toggle('opened');
            }
            else {
              content.classList.toggle('opened');
              await delay(1);
              content.style.maxHeight = content.scrollHeight + 'px'
              return;
            }

            // Disable overlay when closing
            this.background.values.previewOverlay = false;
            this.background.worker.postMessage({
              action: 'updateBackgroundSettings',
              data: { key: 'overlay', value: false }
            });
            this.output.playing = true;
          }
        },
        computed: {
          params() {
            return Object.fromEntries(new URLSearchParams(location.search));
          }
        }
      })
    </script>
  </body>
</html>
