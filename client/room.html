<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Build a Thing Video App</title>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <div id="app">
      <main id="videos">
        <nav>
          <form id="lock-room" @submit.prevent="lockRoom">
            <input type="text" id="access-code" placeholder="Access Code" :disabled="roomLocked" v-model="inputAccessCode" />
            <button id="lock-button" :class="{ 'lock-button': true, 'locked': roomLocked, 'unlocked': !roomLocked }">{{ roomLocked ? "Click to Unlock" : "Click to Lock" }}</button>
          </form>
        </nav>
        <section class="video-streams video-streams__publishers">
          <h2>Publishers</h2>
          <div id="publishers"></div>
        </section>
        <section class="video-streams video-streams__subscribers">
          <h2>Subscribers</h2>
          <div id="subscribers"></div>
        </section>
        <section class="background-preferences">
          <button @click="background.open = !background.open">{{ background.open ? 'Close' : 'Customize Background' }}</button>
          <div class="content" ref="backgroundContent">
            <video  class="hidden"  ref="inputVideo"      :width="output.width" :height="output.height" autoplay @play="handleInputPlay" ></video>
            <canvas class="preview" ref="outputCanvas"    :width="output.width" :height="output.height" @click="handlePreviewClick" :style="{ cursor: background.picking ? 'crosshair' : 'unset' }"></canvas>
            <canvas class="hidden"  ref="workspaceCanvas" :width="output.width" :height="output.height"></canvas>
            <button @click="output.playing = !output.playing">{{ output.playing ? 'Pause' : 'Play' }}</button>
            <form autocomplete="off" ref="backgroundForm">
              <fieldset>
                <legend>Background</legend>
                <span>

                  <label for="image-input">Image</label>
                  <span>
                    <input id="image-input" type="file" accept="image/*" ref="imageInput" @change="handleBackgroundImageChange" />
                    <button id="remove-image" type="button" @click="removeBackgroundImage">Clear</button>
                  </span>

                  <label for="preview-overlay-input">Preview Overlay</label>
                  <input id="preview-overlay-input" type="checkbox" :disabled="!background.image" v-model="background.values.previewOverlay" />

                  <label for="x-input">X</label>
                  <input id="x-input" type="number" step="1" :disabled="!background.image" v-model.number="background.values.x" />

                  <label for="y-input">Y</label>
                  <input id="y-input" type="number" step="1" :disabled="!background.image" v-model.number="background.values.y" />

                  <label for="width-input">Width</label>
                  <input id="width-input" type="number" min="0" step="1" :disabled="!background.image" v-model.number="background.values.width" />

                  <label for="height-input">Height</label>
                  <input id="height-input" type="number" min="0" step="1" :disabled="!background.image" v-model.number="background.values.height" />

                  <label for="darkestChroma-input">Chroma Dark</label>
                  <span>
                    <input id="darkestChroma-input" type="color" :disabled="!background.image" v-model="background.values.darkestChroma" />
                    <button @click="handlePickButton('darkestChroma')" type="button" :disabled="!background.image">{{ background.picking === 'darkestChroma' ? 'Stop Picking' : 'Pick' }}</button>
                  </span>

                  <label for="lightestChroma-input">Chroma Light</label>
                  <span>
                    <input id="lightestChroma-input" type="color" :disabled="!background.image" v-model="background.values.lightestChroma" />
                    <button @click="handlePickButton('lightestChroma')" type="button" :disabled="!background.image">{{ background.picking === 'lightestChroma' ? 'Stop Picking' : 'Pick' }}</button>
                  </span>

                  <label for="tolerance-input">Tolerance %</label>
                  <input id="tolerance-input" type="number" min="0.001" max="100" step="0.1" :disabled="!background.image" v-model.number="background.values.tolerance" />
                </span>
              </fieldset>
              <fieldset>
                <legend>Output</legend>
                <span>
                  <label for="output-width-input">Width</label>
                  <input id="output-width-input" type="number" min="0" step="1" v-model.number="output.width" />

                  <label for="output-height-input">Height</label>
                  <input id="output-height-input" type="number" min="0" step="1" v-model.number="output.height" />

                  <label for="output-fps-input">FPS</label>
                  <input id="output-fps-input" type="number" min="0" step="1" v-model.number="output.frameRate" />
                </span>
              </fieldset>
            </form>
          </did>
        </section>
      </main>
      <aside id="chat">
        <ul id="messages">
          <li v-for="item in messages">
            <label>{{item.username}}</label>
            <div>{{item.message}}</div>
          </li>
        </ul>
        <form id="new-message" @submit.prevent="submitMessage">
          <input type="text" id="message" placeholder="New Message..." v-model="newMessage" />
          <button>Send</button>
        </form>
      </aside>
    </div>

    <script src="https://static.opentok.com/v2/js/opentok.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
    <script>
      /**
       * Create Promise that delays by ms
       */
      const delay = ms => new Promise(resolve => setTimeout(resolve, ms))

      /**
       * Convert number to two-lenghed hex string
       */
      const componentToHex = c => c.toString(16).padStart(2, '0')

      /**
       * Convert RGB to Hex
       */
      const rgbToHex = (r, g, b) => '#' + componentToHex(r) + componentToHex(g) + componentToHex(b)


      const app = new Vue({
        el: '#app',
        data: {
          session: undefined,
          camera: undefined,
          subscribers: [],
          roomLocked: false,
          resp: undefined,
          inputAccessCode: '',
          messages: [],
          newMessage: '',
          background: {
            values: {
              previewOverlay: false,
              x: 0,
              y: 0,
              width: 0,
              height: 0,
              darkestChroma: '#63992E',
              lightestChroma: '#00FF55',
              tolerance: 5,
            },
            picking: null,
            image: undefined,
            open: false,
            context: undefined,
            worker: undefined
          },
          output: {
            width: 0,
            height: 0,
            frameRate: 60,
            playing: false,
            context: undefined
          },
          lastRender: 0
        },
        mounted() {
          // Store the context of both canvases
          this.output.context = this.$refs.outputCanvas.getContext('2d')
          this.background.context = this.$refs.workspaceCanvas.getContext('2d')
        },
        async created() {
          this.spawnWorker()
          // Add watcher for each background value that
          // calls updateBackgroundSetting with the matching key
          Object.entries(this.background.values).forEach(([key, value]) =>
            this.$watch(`background.values.${key}`, (...args) => this.updateBackgroundSetting(key, ...args))
          )

          this.resp = await fetch(`/api/session?room=${this.params.id}&code=${this.params.code}`).then(r => r.json())
          const { apiKey, sessionId, token, locked, access } = this.resp
          if(!access) window.location.replace(`/access-required?id=${this.params.id}&username=${this.params.username}`)
          this.session = OT.initSession(apiKey, sessionId)
          const userStream = await this.getUserStream()
          this.camera = OT.initPublisher('publishers', { mirror: false, name: this.params.username, insertMode: 'append', videoSource: userStream.getVideoTracks()[0], audioSource: userStream.getAudioTracks()[0] })
          this.roomLocked = locked
          this.setLock(this.roomLocked,(this.params.code ? this.params.code : ""))
          this.session.connect(token, () => { this.session.publish(this.camera) })
          this.session.on('streamCreated', event => {
            this.subscribers.push(event.stream)
            this.session.subscribe(event.stream, 'subscribers', { insertMode: 'append' })
          })
          this.session.on('streamDestroyed', event => {
            this.subscribers = this.subscribers.filter(sub => sub.id != event.stream.id)
          })
          this.session.on('signal', event => {
            switch (event.type) {
              case 'signal:message':
                this.messages.push(JSON.parse(event.data))
                break
              case 'signal:lock':
                const lockData = JSON.parse(event.data)
                this.setLock(lockData.lock,lockData.code)
                break
            }
          })
        },
        methods: {
          setLock(locked, code) {
            this.inputAccessCode = code
            this.roomLocked = locked
          },
          submitMessage() {
            if(this.newMessage) {
              this.session.signal({
                data: JSON.stringify({username: this.params.username, message: this.newMessage }),
                type: 'message'
              })
              this.newMessage = ''
            }
          },
          async lockRoom() {
            const { apiKey, sessionId, token, locked } = await fetch(`/api/session?room=${this.params.id}&lock=${!this.roomLocked}&code=${this.inputAccessCode}`).then(r => r.json())
            this.roomLocked = locked
            this.session.signal({
              data: JSON.stringify({lock: locked, code: this.inputAccessCode }),
              type: 'lock'
            })
            this.setLock(this.roomLocked, this.inputAccessCode)
          },
          spawnWorker() {
            this.background.worker = new Worker('./worker.js')
            this.background.worker.addEventListener('message', ({ data }) =>
              // Only message sent from worker is the updated image data,
              // so it can be directly constructed and put on the image
              this.output.context.putImageData(new ImageData(new Uint8ClampedArray(data.buffer), data.width, data.height), 0, 0)
            )
          },
          async getUserStream() {
            // Get a video device from the user, setting the <video> src to it.
            const inputStream = await navigator.mediaDevices.getUserMedia({ video: true })
            this.$refs.inputVideo.srcObject = inputStream

            // Get the stream from the output canvas, and add all audio tracks
            // found on the video source
            const stream = this.$refs.outputCanvas.captureStream()
            const audioTracks = (this.$refs.inputVideo.audioTracks || [])
            audioTracks.forEach(audioTrack => stream.addTrack(audioTrack))
            return stream
          },
          removeBackgroundImage() {
            // Remove the background image, update the worker, and clear the file <input> value
            this.background.image = null
            this.background.worker.postMessage({ action: 'removeBackgroundImage' })
            this.$refs.imageInput.value = ''
          },
          setBackgroundImage(image, limitToInputVideoSize) {
            // Set the background image, optionally scaling it down
            let { width, height } = image

            if (limitToInputVideoSize) {
              // Reduce image size to be less then the input video size while maintaining aspect ratio
              // First by width, then by height
              if (width > this.$refs.inputVideo.width) {
                const ratio = width / height
                width = Math.min(width, this.$refs.inputVideo.width)
                height = width / ratio
              }

              if (height > this.$refs.inputVideo.height) {
                const ratio = height / width
                height = Math.min(height, this.$refs.inputVideo.height)
                width = height / ratio
              }

              image.width = width
              image.height = height
            }

            // Update form values
            this.background.values.width = width
            this.background.values.height = height

            // Save image for future resolution adjustments
            this.background.image = image

            // Obtain image data for image, and send it to the web worker
            const canvas = document.createElement('canvas')
            canvas.width = width
            canvas.height = height

            const context = canvas.getContext('2d')
            context.drawImage(image, 0, 0, width, height)
            const imageData = context.getImageData(0, 0, width, height)

            this.background.worker.postMessage({
              action: 'setBackgroundImage',
              data: {
                buffer: imageData.data.buffer,
                width: imageData.width,
                height: imageData.height
              }
            }, [imageData.data.buffer])
          },
          handleBackgroundImageChange({ target: { files: [imageFile] }}) {
            // Whenever the file <input> changes, set the background image to the first image
            if (!imageFile) return this.removeBackgroundImage()

            // Convert file to image
            const image = new Image()
            image.onload = () => this.setBackgroundImage(image, true)
            image.src = URL.createObjectURL(imageFile)
          },
          updateBackgroundSetting(key, value) {
            // Handle all backround setting updates
            if (value === '') return

            switch(key){
              case 'x':
              case 'y':
              case 'tolerance':
              case 'previewOverlay':
              case 'darkestChroma':
              case 'lightestChroma':
                // Send updated value straight to web worker
                return this.background.worker.postMessage({
                  action: 'updateBackgroundSettings',
                  data: { key, value }
                })
              case 'width':
              case 'height':
                // Update the dimensions of the image, then update web worker
                this.background.image[key] = value
                return this.setBackgroundImage(this.background.image, false)
              default:
                console.error(`Unexpected background setting key: ${key}`)
            }
          },
          handlePickButton(which) {
            this.background.picking = this.background.picking === which ? null : which
          },
          handlePreviewClick({ clientX, clientY, target }) {
            // Get the X and Y of the real image from the clicked canvas
            const rect = target.getBoundingClientRect()
            const widthRatio = this.output.width / rect.width
            const heightRatio = this.output.height / rect.height
            const x = (event.clientX - rect.left) * widthRatio
            const y = (event.clientY - rect.top) * heightRatio

            // Get the clicked pixel and set the current picking color to it's hex value
            const pixel = this.output.context.getImageData(x, y, 1, 1).data
            this.background.values[this.background.picking] = rgbToHex(...pixel)
          },
          handleInputPlay() {
            // Get metadata from video and start rendering
            this.output.playing = true
            this.output.width = this.$refs.inputVideo.videoWidth
            this.output.height = this.$refs.inputVideo.videoHeight
            this.output.frameRate = this.$refs.inputVideo.srcObject.getVideoTracks()[0].getSettings().frameRate
            this.renderFrame()
          },
          renderFrame() {
            // Prevent rendering faster then the frame rate of the input video
            const now = performance.now()
            if (now - this.lastRender < 1000 / this.output.frameRate) return requestAnimationFrame(this.renderFrame)
            this.lastRender = now

            // Stop rendering if the video is stopped
            if (this.$refs.inputVideo.ended) return

            if (this.background.image) {
              // Pass frame data to worker
              this.background.context.drawImage(this.$refs.inputVideo, 0, 0, this.output.width, this.output.height)

              const { data: { buffer }, width, height } = this.background.context.getImageData(0, 0, this.output.width, this.output.height)
              this.background.worker.postMessage({
                action: 'applyGreenscreenEffect',
                data: { buffer, width, height }
              }, [buffer])
            }
            else {
              // Otherwise draw actual raw frame
              this.output.context.drawImage(this.$refs.inputVideo, 0, 0, this.output.width, this.output.height)
            }

            requestAnimationFrame(this.renderFrame)
          }
        },
        watch: {
          'output.playing'(playing) {
            // Pause/Play the video based on the status of output.playing
            if (playing) this.$refs.inputVideo.play()
            else this.$refs.inputVideo.pause()
          },
          async 'background.open'(open) {
            const content = this.$refs.backgroundContent

            if (open) {
              content.classList.toggle('opened')
              await delay(1)
              content.style.maxHeight = content.scrollHeight + 'px'
              return
            }

            content.style.maxHeight = null
            await delay(1800)
            content.classList.toggle('opened')

            // Disable overlay and un-pause video when closing
            this.background.values.previewOverlay = false
            this.background.worker.postMessage({
              action: 'updateBackgroundSettings',
              data: { key: 'previewOverlay', value: false }
            })
            this.output.playing = true
          }
        },
        computed: {
          params() {
            return Object.fromEntries(new URLSearchParams(location.search));
          }
        }
      })
    </script>
  </body>
</html>
