<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Build a Thing Video App</title>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <div id="app">
      <main id="videos">
        <nav>
          <form id="lock-room" @submit.prevent="lockRoom">
            <input type="text" id="access-code" placeholder="Access Code" :disabled="roomLocked" v-model="inputAccessCode" />
            <button id="lock-button" :class="{ 'lock-button': true, 'locked': roomLocked, 'unlocked': !roomLocked }">{{ roomLocked ? "Click to Unlock" : "Click to Lock" }}</button>
          </form>
        </nav>
        <section class="video-streams video-streams__publishers">
          <h2>Publishers</h2>
          <div id="publishers"></div>
        </section>
        <section class="video-streams video-streams__subscribers">
          <h2>Subscribers</h2>
          <div id="subscribers"></div>
        </section>
        <section class="background-preferences">
          <button v-on:click="toggleBackgroundForm">Customize Background</button>
          <div class="content" ref="backgroundContent">
            <video autoplay class="hidden" ref="inputVideo" v-on:play="handleInputPlay"></video>
            <canvas class="preview" ref="outputCanvas"></canvas>
            <canvas class="hidden" ref="workspaceCanvas"></canvas>
            <form id="background-image-form" autocomplete="off" ref="backgroundForm" v-on:change="handleBackgroundFormChange">
              <label for="image-input">Background Image</label>
              <span>
                <input id="image-input" type="file" ref="imageInput" />
                <button id="remove-image" type="button" v-on:click="removeImage">Clear</button>
              </span>

              <label for="overlay-input">Overlay</label>
              <input id="overlay-input" type="checkbox" disabled v-model="background.forceOverlay" />

              <label for="x-input">X</label>
              <input id="x-input" type="number" step="1" value="0" disabled v-model="background.x" />

              <label for="y-input">Y</label>
              <input id="y-input" type="number" step="1" value="0" disabled v-model="background.y" />

              <label for="width-input">Width</label>
              <input id="width-input" type="number" min="0" step="1" disabled v-model="background.width" />

              <label for="height-input">Height</label>
              <input id="height-input" type="number" min="0" step="1" disabled v-model="background.height" />

              <label for="lowerChroma-input">Chroma Min</label>
              <input id="lowerChroma-input" type="color" v-model="background.lowerChroma" />

              <label for="upperChroma-input">Chroma Max</label>
              <input id="upperChroma-input" type="color" v-model="background.upperChroma" />
            </form>
          </did>
        </section>
      </main>
      <aside id="chat">
        <ul id="messages">
          <li v-for="item in messages">
            <label>{{item.username}}</label>
            <div>{{item.message}}</div>
          </li>
        </ul>
        <form id="new-message" @submit.prevent="submitMessage">
          <input type="text" id="message" placeholder="New Message..." v-model="newMessage" />
          <button>Send</button>
        </form>
      </aside>
    </div>

    <script src="https://static.opentok.com/v2/js/opentok.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
    <script>
      /**
       * Convert hexcode color to RGB
       *
       * From https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
       */
      const hexToRGB = hex => {
        if (hex[0] == '#') hex = hex.substring(1);
        const bigint = parseInt(hex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;

        return [r, g, b];
      }

      /**
       * Create Promise that delays by ms
       */
      const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

      const app = new Vue({
        el: '#app',
        data: {
          session: undefined,
          camera: undefined,
          subscribers: [],
          roomLocked: false,
          resp: undefined,
          inputAccessCode: '',
          messages: [],
          newMessage: '',
          background: {
            forceOverlay: false,
            getUserStream: null,
            open: false,
            image: undefined,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            lowerChroma: '#63992E',
            upperChroma: '#00FF55',
            outputContext: undefined,
            workspaceContext: undefined,
            worker: undefined
          },
          frameRate: 60,
          lastRender: 0
        },
        mounted(){
          this.background.outputContext = this.$refs.outputCanvas.getContext('2d');
          this.background.workspaceContext = this.$refs.workspaceCanvas.getContext('2d');
        },
        async created() {
          this.spawnWorker();
          this.resp = await fetch(`/api/session?room=${this.params.id}&code=${this.params.code}`).then(r => r.json())
          const { apiKey, sessionId, token, locked, access } = this.resp
          if(!access) window.location.replace(`/access-required?id=${this.params.id}&username=${this.params.username}`)
          this.session = OT.initSession(apiKey, sessionId)
          const userStream = await this.getUserStream();
          this.camera = OT.initPublisher('publishers', { mirror: false, name: this.params.username, insertMode: 'append', videoSource: userStream.getVideoTracks()[0], audioSource: userStream.getAudioTracks()[0] })
          this.roomLocked = locked
          this.setLock(this.roomLocked,(this.params.code ? this.params.code : ""))
          this.session.connect(token, () => { this.session.publish(this.camera) })
          this.session.on('streamCreated', event => {
            this.subscribers.push(event.stream)
            this.session.subscribe(event.stream, 'subscribers', { insertMode: 'append' })
          })
          this.session.on('streamDestroyed', event => {
            this.subscribers = this.subscribers.filter(sub => sub.id != event.stream.id)
          })
          this.session.on('signal', event => {
            switch (event.type) {
              case 'signal:message':
                this.messages.push(JSON.parse(event.data))
                break
              case 'signal:lock':
                const lockData = JSON.parse(event.data)
                this.setLock(lockData.lock,lockData.code)
                break
            }
          })
        },
        methods: {
          setLock(locked, code) {
            this.inputAccessCode = code
            this.roomLocked = locked
          },
          submitMessage() {
            if(this.newMessage) {
              this.session.signal({
                data: JSON.stringify({username: this.params.username, message: this.newMessage }),
                type: 'message'
              })
              this.newMessage = ''
            }
          },
          async lockRoom() {
            const { apiKey, sessionId, token, locked } = await fetch(`/api/session?room=${this.params.id}&lock=${!this.roomLocked}&code=${this.inputAccessCode}`).then(r => r.json())
            this.roomLocked = locked
            this.session.signal({
              data: JSON.stringify({lock: locked, code: this.inputAccessCode }),
              type: 'lock'
            })
            this.setLock(this.roomLocked, this.inputAccessCode)
          },
          async toggleBackgroundForm({ target }) {
            this.background.open = !this.background.open;
            const content = this.$refs.backgroundContent;
            const isOpen = content.classList.contains('opened');

            if (isOpen) {
              content.style.maxHeight = null;
              await delay(1800);
              content.classList.toggle('opened');
            }
            else {
              content.classList.toggle('opened');
              await delay(1);
              content.style.maxHeight = content.scrollHeight + 'px'
            }

            target.textContent = !isOpen ? 'Close' : 'Customize Background';
            if (!isOpen) return;

            // Disable overlay when closing
            this.background.forceOverlay = false;
            this.background.worker.postMessage({
              action: 'updateBackground',
              data: { overlay: false }
            });
          },
          setFormEnabled(enabled){
            [...this.$refs.backgroundForm.querySelectorAll('input, button')]
              .filter(input => input.id !== 'image-input')
              .forEach(input => input.disabled = !enabled)
          },
          spawnWorker(){
            this.background.worker = new Worker('./worker.js');
            this.background.worker.onmessage = event => {
              // Only message sent from worker is the updated image data
              const imageData = new ImageData(new Uint8ClampedArray(event.data), this.$refs.inputVideo.width, this.$refs.inputVideo.height);
              this.background.outputContext.putImageData(imageData, 0, 0);
              requestAnimationFrame(this.render);
            }
          },
          removeImage(){
            this.background.image = null;
            this.background.worker.postMessage({ action: 'removeBackgroundImage' });
            this.$refs.imageInput.value = '';
          },
          setBackgroundImage(image, limitToInputVideoSize){
            let { width, height } = image;

            if (limitToInputVideoSize){
              // Reduce image size to be less then the input video size while maintaining aspect ratio
              if (width > this.$refs.inputVideo.width){
                const ratio = width / height;
                width = Math.min(width, this.$refs.inputVideo.width);
                height = width / ratio;
              }

              if (height > this.$refs.inputVideo.height){
                const ratio = height / width;
                height = Math.min(height, this.$refs.inputVideo.height);
                width = height / ratio;
              }

              image.width = width;
              image.height = height;
            }

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;

            // Update form values
            this.background.width = width;
            this.background.height = height;

            // Save image for future resolution adjustments
            this.background.image = image;

            const context = canvas.getContext('2d');
            context.drawImage(image, 0, 0, width, height);
            const imageData = context.getImageData(0, 0, width, height);
            this.background.worker.postMessage({
              action: 'setBackgroundImage',
              data: {
                pixels: imageData.data.buffer,
                width: imageData.width,
                height: imageData.height
              }
            }, [imageData.data.buffer]);
          },
          handleBackgroundFormChange({ target: input }){
            const name = input.id.split('-input')[0];

            if (name === 'image') {
                this.setFormEnabled(true)
                const imageFile = input.files[0];
                if (!imageFile) return;

                // Convert file to image
                const image = new Image();
                image.onload = () => this.setBackgroundImage(image, true);
                image.src = URL.createObjectURL(imageFile);
                return;
            }

            switch(name){
              case 'x':
              case 'y':
              case 'overlay':
                // Post updated preference:
                // value as number for x/y, true/false boolean for overlay
                return this.background.worker.postMessage({
                  action: 'updateBackground',
                  data: {
                    [name]: name === 'overlay' ? input.checked : parseInt(input.value)
                  }
                });
              case 'lowerChroma':
              case 'upperChroma':
                return this.background.worker.postMessage({
                  action: 'updateBackground',
                  data: { [name]: hexToRGB(input.value) }
                });
              case 'width':
              case 'height':
                // Update the dimensions of the image and update the image data
                this.background.image[name] = parseInt(input.value);
                return this.setBackgroundImage(this.background.image, false);
            }
          },
          handleInputPlay(){
            // Update dimensions of canvases and video when video metadata loads
            for (const element of [this.$refs.outputCanvas, this.$refs.workspaceCanvas, this.$refs.inputVideo]){
              element.width = this.$refs.inputVideo.videoWidth
              element.height = this.$refs.inputVideo.videoHeight;
            }

            // Get frame rate and start rendering
            this.frameRate = this.$refs.inputVideo.srcObject.getVideoTracks()[0].getSettings().frameRate;
            this.render();
          },
          render(){
            // Prevent rendering faster then the frame rate of the input video
            const now = performance.now();
            if (now - this.lastRender < 1000 / this.frameRate) return requestAnimationFrame(() => this.render());
            this.lastRender = now;

            // Stop rendering if the video is stopped
            if (this.$refs.inputVideo.ended || this.$refs.inputVideo.paused) return;

            if (this.background.image) {
              // Pass frame data to worker
              this.background.workspaceContext.drawImage(this.$refs.inputVideo, 0, 0);
              const imageData = this.background.workspaceContext.getImageData(0, 0, this.$refs.inputVideo.videoWidth, this.$refs.inputVideo.videoHeight);
              this.background.worker.postMessage({
                action: 'applyGreenscreenEffect',
                data: {
                  pixels: imageData.data.buffer,
                  width: imageData.width,
                  height: imageData.height
                }
              }, [imageData.data.buffer]);
              return;
            }

            // There is no background, pass image directly to the output canvas
            this.background.outputContext.drawImage(this.$refs.inputVideo, 0, 0);
            requestAnimationFrame(() => this.render());
          },
          async getUserStream(){
            const inputStream = await navigator.mediaDevices.getUserMedia({ video: true });
            this.$refs.inputVideo.srcObject = inputStream;

            const stream = this.$refs.outputCanvas.captureStream();
            const audioTracks = (this.$refs.inputVideo.audioTracks || []);
            if (audioTracks.length) stream.addTrack(audioTracks[0]);
            return stream;
          }
        },
        computed: {
          params() {
            return Object.fromEntries(new URLSearchParams(location.search));
          }
        }
      })
    </script>
  </body>
</html>
